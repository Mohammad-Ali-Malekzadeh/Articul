""" Persian description --------------------------- Floating Point Arithmetic: Issues and Limitations ------ P
! محاسبه اعداد اعشاری - مسائل و محدودیت ها

در سخت افزار کامپیوتر بصورت دو دویی یا باینری محاسبه می شوند Floating-point numbers

? decimal fraction: کسر ده دهی
در سیستم ده دهی اعداد اعشاری به این صورت ارزش بندی میشوند
0.625 = 6/10 + 2/100 + 5/1000    <-------------------------]
.                                                          |
? binary fraction: کسر باینری - دو دویی                   |
در سیستم دودویی هم به این صورت                           |
0.101 = 1/2 + 0/4 + 1/8 = 0.625                            |
  |||                                                      |
  |||                                                      |
  |||                                                      |
  |||___ 1 * 2 ^ -3 = 0.125 --]                            |
  ||                                                       |
  ||___ 0 * 2 ^ -2 = 0      --|----> 0.125 + 0 + 0.5 = 0.625 (بر پایه ده - decimal)
  |
  |___ 1 * 2 ^ -1 = 0.5     --]
پایه 10 و دومی در پایه 2 نوشته شده است (fractional notation) این دو کسر مقادیر یکسانی دارند، تنها تفاوت واقعی این است که اولی با نماد کسری
 
مشکل محاسبه در اعداد اعشاری در پایه 10 خیلی قابل فهم تر است
کسر 1/3 را در نظر بگیرید و بخواهیم با پایه 10 تقربی بزنیم
میشه:
0.3
بهترش کنیم
0.33
یا بهتر:
0.333
نتیجه هرگز دقیقاً 1/3 نخواهد بود و به آن میتونیم نزدیک شیم

در پایه 2 کسر 1/10 بی نهایت تکراری می باشد.
0.0001100110011001100110011001100110011001100110011...

! approximate binary fraction
در بیشتر ماشین های امروزی اعداد اعشاری با کمک روش زیر تخمین زده میشن:
پنجاه و سه بیت که از مهم ترین بیت شروع میشود و مخرج آن به توان 2 میرسدbinary fraction در صورت کسر 

ه true decimal value رو به عنوان decimal خیلی از کاربرها به خاطر نحوه نمایش مقادیر از تقریب خبر دار نیستند و پایتون تقریب
تقریب باینری ذخیره شده در ماشین را نشان میدهد

ذخیره شده برای 0.1 نشان دهد داریم true decimal value of the binary approximation اگر پایتون بخواهد :
>>> 0.1
0.1000000000000000055511151231257827021181583404541015625

بنابر این چون بیشتر اعداد برای کاربران کاربرد ندارد، پایتون به جاش رند شدش رو نشون میده.
را به هم دارند approximate binary fraction جالب اینجاست که اعداد اعشاری مختلف زیادی وجود دارند که نزدیکترین 
مانند مثال های زیر:
0.1
0.10000000000000001
0.1000000000000000055511151231257827021181583404541015625
که همه 👆 ها را  با 3602879701896397 / 2 ** 55 تقریب زده میشن
"""

print("------------ 1st Example ------------")
print("any one of them could be displayed while still preserving the invariant")
x = 0.10000000000000001
y = 0.10000000000000099
print(eval(repr(x)) == x)
print(x)
print(y)

""" 
میاد و 17 تا از مهم ترین اعداد انتخاب میکنه repr() ه built-in از لحاظ تاریخی  تابع
از زمانی که پایتون 3 اومد کوتاه ترین عدد رو برمیداره و 0.1 خود به خود به جای 0.100000000000001 نشون میده

سخت‌افزار شما پشتیبانی می‌کنند، چیزهای مشابهی خواهید دید و یک باگ در پایتون نیستfloating-point arithmetic در همه زبان‌هایی که از

برای خروجی دلپذیر تر،  ممکن است بخواهید از رشته ها برای تولید تعداد محدودی ارقام قابل توجه و مهم استفاده کنید
"""

print("------------ 2nd Example ------------")
import math

print(format(math.pi, ".12g"))  # give 12 significant digits
print(format(math.pi, ".2f"))  # give 2 digits after the point
# میبینیم که تابع زیر 17 تا عدد برمیگردونه
print(repr(math.pi))

""" 
را گرد میکنید display of the true machine value نکته مهم اینجاست که کلا این مسعله یک توهم است و شما به سادگی
یا توهم میتواند توهم های دیگری ایجاد کند illusion یک 
از آنجایی که 0.1 دقیقا برابر 1/10 نیست، جمع کردن 3 تا 0.1 دقیقا برابر 0.3 نمی باشد
"""

print("------------ 3th Example ------------")
print(0.1 + 0.1 + 0.1 == 0.3)

""" 
? pre-rounding  
هم کمکی برای حل این مسعله نمیکند round() همچنین از آنجایی که 0.1 نمیتواند به 1/10 و 0.3 به 3/10 نزدیک تر شود پس پیش-گرد کردن با تابع
"""

print("------------ 4th Example ------------")
print(round(0.1, 1) + round(0.1, 1) + round(0.1, 1) == round(0.3, 1))

""" 
? post-rounding
برای پس-گرد کردن راه حل مناسبی هست round() تابع 
به طوری که نتایج با مقادیر غیر دقیق با یکدیگر قابل مقایسه باشند
"""

print("------------ 5th Example ------------")
print(round(0.1 + 0.1 + 0.1) == round(0.3))

""" 
استفاده کرد decimal برای محاسبه دقیق اعداد اعشاری هنگام برنامه های حساب داری و برنامه های کاربردی با دقت بالا میتوان از ماژول
استفاده کرد زیرا محاسبات رو بر اساس اعداد گویا اجرا میکند fractions یا میتوان از ماژول
توسعه داده میشه استفاده کنید SciPy و پکیج های دیگری که توسط پروژه Numpy هستید باید از floating point operations اگر کاربر دائمی 
? float.as_integer_ratio()
بدانید کمک میکند exact value of a float پایتون ابزارهایی را ارائه می دهد که ممکن است در موارد نادری که واقعاً می خواهید
برمیگرداند fraction روبه عنوان float این تابع مقدار یک

"""
print("------------ 6th Example ------------")
x1 = 3.14159
print(x.as_integer_ratio())

""" 
از آنجایی که نسبت دقیق است، می توان از آن برای بازآفرینی بدون ضرر مقدار اصلی استفاده کرد:
"""

print("------------ 7th Example ------------")
print(x1 == 3537115888337719 / 1125899906842624)

""" 
در پایه هگزادسیمال (پایه 16) بیان می کند، که دوباره مقدار دقیق ذخیره شده توسط رایانه شما را نشان می دهد float یک 
"""

print("------------ 8th Example ------------")
print(x1.hex())

""" 
استفاده کرد value exactly دقیق را میتوان برای بازسازی hexadecimal این نمایش
"""

print("------------ 9th Example ------------")
print(x1 == float.fromhex("0x1.921f9f01b866ep+1"))

""" 
از آنجایی که نمایش دقیق است، برای انتقال مطمئن مقادیر در نسخه‌های مختلف پایتون (استقلال پلتفرم) و تبادل داده با
زبان‌های دیگری که از فرمت یکسانی پشتیبانی می‌کنند (مانند جاوا) مفید است

م(افت دقت) در حین جمع کردن کاهش پیدا کنه loss-of-precision کمک میکند تا math.fsum() تابع 
م(ارقام گم شده) در عملیات جمع کردن اضافه میشود. به طوری که خطاها تا جایی جمع نمیشوند که بر کل نهایی تاثیر گذار باشد lost digits
"""

print("------------ 10th Example ------------")
print(sum([0.1] * 10) == 1.0)
print(math.fsum([0.1] * 10) == 1.0)

""" 
? Representation Error
در بیشتر کسر ها دقیقا با باینری نمایش داده نمیشودdecimal fractions م(خطای نمایش) به این واقعیت اشاره داره که Representation error
چرا 1/10 دقیقاً به عنوان یک کسر باینری قابل نمایش نیست؟
استفاده می‌کنند IEEE-754 تقریباً همه ماشین‌های امروزی (نوامبر 2000) از محاسبات ممیز شناور 
استفاده میکند IEEE-754 “double precision” پایتون
شامل 53 بیت دقت است.
J/2**N بنابراین در ورودی کامپیوتر تلاش میکند تا 0.1 را به نزدیکترین کسر تبدیل کند که میتواند به این شکل باشد IEEE-754 doubles
یک عدد صحیح حاوی 53 بیت است J که در آن
بازنویسی
1 / 10 ~= J / (2**N)
خواهد بود
J ~= 2**N / 10

برابر 53 دقیقا بیت خواهد بود J میدانیم که 
را طوری پیدا کنیم N می باشد باید (>= 2**52 but < 2**53) که در بازه J برابر عدد 53 نیست. برای محاسبه J نکته جالب اینجاست که مهم نیست 
را دقیقا 53 بیت بگذاردJ که 
این است که گرد شود J بهترین مقدار ممکن برای
در این مثال56 است N بهترین مقدار
"""

print("------------ 11th Example ------------")
print(2**52 <= 2**56 // 10 < 2**53)
q, r = divmod(2**56, 10)
print(r)

"""
با گرد کردن به دست می آید approximation  از آنجایی که باقی مانده بیش از نیمی از 10 است، بهترین تقریب
"""

print("------------ 12th Example ------------")
print(q + 1)

""" 
754 double precision در approximation بنابر این بهترین تقریب
خواهد بود:
"""

print("------------ 13th Example ------------")
print(7205759403792794 / 2 ** 56)
print(3602879701896397 / 2 ** 55)

""" 
توجه داشته باشید که از آنجایی که ما گرد کردیم، این مقدار در واقع کمی بزرگتر از 1/10 است
اگر به بالا گرد نمی کردیم، ضریب کمی کوچکتر از 1/10 بود. اما در هیچ موردی نمی تواند دقیقا 1/10 باشد 

کسر دقیقی) است که در بالا داده شده است ) exact fraction پس هیچ وقت کامیپوتر 1/10 را نمی بیند. آنچه می‌بیند
754 double approximation بهترین
میتوان از روش زیر بدست آورد.

0.1 = J / 2**55 => J = 0.1 * 2 ** 55
"""

print("------------ 14th Example ------------")
print(0.1 * 2 ** 55)

"""
اگر آن کسر را در 10**55 ضرب کنیم، می توانیم مقدار آن را تا 55 رقم اعشاری ببینیم:

"""

print("------------ 15th Example ------------")
print(3602879701896397 * 10 ** 55 // 2 ** 55)

"""
به این معنی که عدد دقیق ذخیره شده در کامپیوتر برابر با مقدار اعشاری 0.100000000000000055511151231257827021181583404541015625 است. به جای نمایش مقدار اعشاری کامل، بسیاری از زبان ها (از جمله نسخه های قدیمی پایتون)، نتیجه را به 17 رقم قابل توجه گرد می کنند
"""

print("------------ 16th Example ------------")
print(format(0.1, '.17f'))

from decimal import Decimal
from fractions import Fraction

print(Fraction.from_float(0.1))
print((0.1).as_integer_ratio())
print(Decimal.from_float(0.1))
print(format(Decimal.from_float(0.1), '.17'))